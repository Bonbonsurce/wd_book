\chapter{Боты в Викиданных}
\label{ch:bots}
\marginnote[2.78cm]{OpenRefine ‒ свободный инструмент для извлечения и очистки табличных данных, которые можно связать с базами знаний, включая Викиданные.}
\marginnote[0.0cm]{QuickStatements ‒ это сервис пакетной обработки Викиданных.}
В этой главе рассматривается автоматизация процессов в Викиданных. Во многих случаях мы хотим исправить повторяющиеся ошибки или ввести большие объемы данных в Викиданные вместо того, чтобы изменять свойства по одному. Для ввода данных в нашем распоряжении имеется несколько инструментов, облегчающих нашу работу, таких как OpenRefine или QuickStatements, но повторяющиеся изменения и вставки со временем должны выполняться с помощью бота.

\section{Требования}
\label{sec:requirements}
Мы можем запрограммировать бота на нескольких языках программирвания, но, чтобы облегчить нашу задачу, мы можем использовать Pywikibot, набор инструментов, запрограммированных на Python для облегчения доступа к информации в проектах Фонда Викимедиа. У нас есть три варианта запуска наших программ:
\begin{enumerate}
  \setlength{\itemindent}{2em}
  \item использовать веб-оболочку, такую как PAWS,
  \marginnote[0.0cm]{PAWS (a web shell) - веб-оболочка - сервис, в котором размещаются блокнонты Jupyter для использования всеми участниками Викимедиа}
  \item создать облаччную инфраструктуру, такую как Toolforge, или 
  \marginnote[0.0cm]{Toolforge - среда размещения, также известная как <<Платформа как Услуга (Platform as a Service)>>}
  \item запустить на нашем собственном компьютере.
\end{enumerate}

Любой из этих трех вариантов может быть использован благодаря объяснениям, которые есть в официальной документации.\marginnote[0.0cm]{См. руководство по установке Pywikibot, \url{https://w.wiki/4CsU}} Если мы используем собственный компьютер, мы должны установить Python, следуя инструкциям в документации. После установки мы можем проверить, корректно ли он установлен, нажав <<py -V>> в командной строке Windows или в консоли Linux (в дальнейшем все должно быть сделано отсюда), и он покажет нам версию, с которой мы будем работать. Затем мы должны установить Pywikibot и настроить его. Эта конфигурация состоит из нескольких этапов:

\begin{itemize}
  \setlength{\itemindent}{2em}
  \item Выполните следующую команду, чтобы создать файл конфигурации: <<py pwb.py generate\_user\_files>>.
  \item Выполните следующую команду для входа в систему: <<py pwb.py login>>.
  \item Просмотрите файлы user-config.py и user-password.py, где мы можем указать имена пользователей, которые будут вносить изменения.
\end{itemize}

Для просмотра информации или выполнения небольших тестов мы можем использовать наше имя пользователя, но в случае внесения большого количества изменений в Викиданные рекомендуется создать учетную запись бота и запросить разрешение на запуск. Чтобы иметь этот флаг, обычно требуются некоторые знания о редактировании в проектах Викимедиа, которые подтверждают, что мы не сделаем серьезных ошибок и у нас есть поддержка других пользователей.

Обычно для получения этого флага нас просят выполнить определенное количество тестовых выпусков, чтобы удостовериться, что такие изменения имеют смысл, поскольку у нас должен быть низкий или нулевой коэффициент ошибок. Мы также можем выполнять задачи через нашу учетную запись, но с небольшим количеством правок.

\section{Наш первый скрипт}
\label{sec:firstScript}
После того, как мы правильно настроили Pywikibot, мы можем запустить 
наш первый скрипт~(листинг~\ref{lst:page-get}). 
Перейдем в папку, в которой находится Pywikibot, и создадим новый файл с именем test.py.

Мы можем вносить изменения в файл при помощи любых текстовых редакторов 
или редакторов кода, таких как: 
Visual Studio Code, Notepad++ или обычного Notepad. 
Открыв файл, добавим в него следующий код~(листинг~\ref{lst:page-get}).

\marginnote[2\baselineskip]{Отметим, что в Викиданных есть две реки с одинаковым названием <<Обница>>, 
одна в Польше, другая в Сербии. Одноимённые объекты легко различимы 
по номерам: \wdqName{Obnitsa}{16583338} и \wdqName{Obnitsa}{959190}.}
%
\begin{lstlisting}[ language=Python,
                    caption={Получение содержимого страницы Викиданных о реке Обнице в Польше},
                    label=lst:page-get
                  ]
import pywikibot
site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q16583338")     # river in Poland
print(page.get())
\end{lstlisting}

Сохраняем файл и выполняем его, набрав следующую инструкцию: ``py pwb.py test.py''.

Если все работает корректно, мы увидим в нашей консоли весь текст, написанный в статье о реке Обница в Викиданных (элемент Q16583338). В первой строке кода мы импортировали Pywikibot. Затем мы указали название проекта, над которым хотим работать, как мы могли бы сделать это на любом языке Википедии или Commons. Затем мы указываем конкретный элемент и, наконец, говорим ему, что хотим получить весь контент.

«Страница»~--- это модуль, который содержит множество методов, которые могут быть нам полезны. Чтобы узнать больше об этом, мы можем перейти к официальной документации. В дополнение к методу «get» в нашем распоряжении есть возможность узнать заголовок элемента с помощью метода «title»:
\marginnote[0.0cm]{См. официальную документацию pywikibot.page, \url{https://doc.wikimedia.org/pywikibot/master/_modules/pywikibot/page.html}}

\begin{lstlisting}[language=Python]
import pywikibot

site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q16583338")
print(page.title())
\end{lstlisting}

Мы также можем узнать, является ли этот элемент страницей перенаправления, с помощью метода isRedirectPage. Для этого изменим предыдущий элемент и укажем другой, который является страницей перенаправления (Q16583333):

\begin{lstlisting}[language=Python]
import pywikibot

site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u" Q16583333")
print(page.title())
print(page.isRedirectPage())
\end{lstlisting}

Внимание: до сих пор упражнения были очень простыми, но по мере продвижения мы должны быть осторожны со вкладками, которые позволяют Python знать, какая информация входит в структуры управления.

Предыдущее упражнение возвращает только истину или ложь, но обычно этот метод используется для того, чтобы спросить, является ли это страницей перенаправления или нет, и действовать соответствующим образом, предупреждая пользователя, что этот элемент является страницей перенаправления, как в следующем примере:

\begin{lstlisting}[language=Python]
import pywikibot

site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u" Q16583333")
if (page.isRedirectPage()):
  print("Attention, this is a redirect, not an element")
\end{lstlisting}

Но что произойдет, если мы проанализируем несколько элементов и найдем тот, которого не существует? Возможно, наша программа вернет несколько ошибок, потому что не сможет проанализировать внутреннюю часть элемента. Для этого мы можем отловить ошибки в Python, но мы также можем спросить, существует ли элемент или нет:

\begin{lstlisting}[language=Python]
import pywikibot

site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u" Q107043778")
if not page.exists():
  print("Sorry, but this element does not exist!")
\end{lstlisting}

Упражнение: узнайте, как мы можем фиксировать ошибки в Python и усовершенствуйте предыдущую программу, чтобы мы могли фиксировать возможные ошибки, возвращаемые программой.

Далее мы проанализируем элемент более глубоко, чтобы узнать все те свойства, которые он включил. Для этого мы можем использовать метод «свойства», как мы здесь описываем:

\begin{lstlisting}[language=Python]
import pywikibot

site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q16583338")
print(page.properties())
\end{lstlisting}

При выполнении этого скрипта мы видим, что этот метод возвращает словарь Python, и это потому, что метод «свойства» возвращает словарь со свойствами, содержащимися в этом элементе. Например, мы видим, что в свойстве page\_image\_free мы получаем изображение, которое появляется в элементе, что wb\_claims содержит количество свойств, введенных в элемент, или что wb\_sitelinks сообщает нам количество ссылок которые существуют для остальных проектов Фонда Викимедиа.

Метод «участники» также возвращает словарь. В этом случае с количеством пользователей, которые внесли свой вклад в элемент. Он покажет нам пользовательские имена всех участников, а также количество выпусков каждого из них. У нас также есть метод revision\_count, который возвращает общее количество изменений, внесенных в элемент, как показано ниже:

\begin{lstlisting}[language=Python]
import pywikibot

site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q16583338")
print(page.contributors())
print(page.revision\_count())
\end{lstlisting}

Существуют и другие методы, которые возвращают более сложную информацию, чем словарь данных, например, объект. Это случай метода «connectedPages». Если мы его используем как и ранее, он вернет: 

<<pywikibot.data.api.PageGenerator object at 0x000002C6C7DB2FD0>>, 
указывая, что он содержит объект типа «PageGenerator». Чтобы прочитать его, мы можем сделать это с помощью цикла for:

\begin{lstlisting}[language=Python]
import pywikibot

site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q16583338")
for linked in page.linkedPages():
  print(linked)
\end{lstlisting}

Как мы видим, этот метод предоставляет нам ссылки, на которые мы можем кликнуть из элемента. Сначала будут показаны элементы, а затем свойства (включая информацию, содержащуюся в ссылках). Очевидно, что если выбранный элемент не очень большой, количество ссылок также будет не очень большим, но если мы попробуем этот пример с очень большим элементом, количество ссылок будет очень большим.

Чтобы знать количество элементов, которые ссылаются на конкретный элемент, у нас также есть метод, называемый «обратные ссылки», который содержит объект и который мы должны пройти, как мы делали в предыдущем упражнении. В зависимости от элемента мы можем найти пустой список, поэтому мы выберем элемент, связанный с другими элементами:

\begin{lstlisting}[language=Python]
import pywikibot

site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q6980876")
for links in page.backlinks():
  print(links)
\end{lstlisting}

В этом случае мы выбрали другую реку, которая связана дважды: другой рекой и страницей перенаправления. Таким образом, мы можем узнать, сколько раз был связан определенный элемент.

Упражнение: примените на практике все, что увидели до этого момента, но используя элемент с низким номером, который, вероятно, содержит гораздо больше информации, чем примеры, которые мы использовали до сих пор.

В дополнение к модулю «Страница» Pywikibot предоставляет нам множество других возможностей. Например, введение одного элемента не имеет особого смысла, обычно мы хотим работать с несколькими элементами, чтобы проанализировать их и, при необходимости, изменить их. Для этого мы можем использовать запросы, которые мы выполняли на протяжении всего курса.
