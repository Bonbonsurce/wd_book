\chapter{Боты в Викиданных}
\label{ch:bots}
\marginnote[2.78cm]{OpenRefine ‒ это свободный инструмент для извлечения и очистки табличных данных, которые можно связать с базами знаний, включая Викиданные.}
\marginnote[0.0cm]{QuickStatements ‒ это сервис пакетной обработки Викиданных.}
В этой главе рассматривается автоматизация процессов в Викиданных. Часто нужно исправить повторяющиеся ошибки или ввести большие объемы данных в Викиданные вместо того, чтобы изменять свойства по одному. Для ввода данных в нашем распоряжении есть несколько инструментов, облегчающих работу, таких как: OpenRefine или QuickStatements, но повторяющиеся изменения и вставки должны выполняться с помощью бота.

\section{Требования}
\label{sec:requirements}
Мы можем запрограммировать бота на нескольких языках программирования, но, чтобы облегчить задачу, воспользуемся библиотекой Pywikibot, написанной на языке Python и предназначенной для облегчения доступа к информации в проектах Фонда Викимедиа. Есть три варианта запуска наших программ:
\begin{enumerate}
  \setlength{\itemindent}{2em}
  \item использовать веб-оболочку, такую как PAWS
  \marginnote[0.0cm]{PAWS (a web shell) - веб-оболочка - сервис, в котором размещаются блокнонты Jupyter для использования всеми участниками Викимедиа}
  \item создать облаччную инфраструктуру, такую как Toolforge
  \marginnote[0.0cm]{Toolforge - среда размещения, также известная как <<Платформа как Услуга (Platform as a Service)>>}
  \item запустить на нашем собственном компьютере.
\end{enumerate}

Благодаря наличию документации можно воспользоваться любым из этих трёх способов.\marginnote[0.0cm]{См. руководство по установке Pywikibot, \url{https://w.wiki/4CsU}} Для работы с ботами со своего компьютера нужно предварительно установить среду и язык программирования Python. После установки мы можем проверить, корректно ли он установлен, набрав ''py -V'' в командной строке Windows или в консоли Linux (в дальнейшем всё делаем в консоли), и консоль покажет нам версию, с которой мы будем работать. Затем устанавливаем Pywikibot и настраиваем его. Эта настройка включает несколько этапов:

\begin{itemize}
  \setlength{\itemindent}{2em}
  \item Выполните следующую команду, чтобы создать файл конфигурации: ''py pwb.py generate\_user\_files''.
  \item Выполните следующую команду для входа в систему: ''py pwb.py login''.
  \item Просмотрите файлы user-config.py и user-password.py, где мы можем указать имена пользователей, которые будут вносить изменения.
\end{itemize}

Для просмотра информации или выполнения небольших тестов мы можем использовать наше имя пользователя, но в случае внесения большого количества изменений в Викиданные рекомендуется создать учетную запись бота и запросить разрешение на запуск. Чтобы иметь этот флаг, обычно требуются некоторые знания о редактировании в проектах Викимедиа, которые подтверждают, что мы не сделаем серьезных ошибок и у нас есть поддержка других пользователей.

Обычно для получения этого флага нас просят выполнить определенное количество тестовых выпусков, чтобы удостовериться, что такие изменения имеют смысл, поскольку у нас должен быть низкий или нулевой коэффициент ошибок. Мы также можем выполнять задачи через нашу учетную запись, но с небольшим количеством правок.

\section{Наш первый скрипт}
\label{sec:firstScript}
После того, как мы правильно настроили Pywikibot, мы можем запустить 
наш первый скрипт~(листинг~\ref{lst:page-get}). 
Перейдем в папку, в которой находится Pywikibot, и создадим новый файл с именем test.py.

Мы можем вносить изменения в файл при помощи любых текстовых редакторов 
или редакторов кода, таких как: 
Visual Studio Code, Notepad++ или обычного Notepad. 
Открыв файл, добавим в него следующий код~(листинг~\ref{lst:page-get}).

\marginnote[2\baselineskip]{Отметим, что в Викиданных есть две реки с одинаковым названием <<Обница>>, 
одна в Польше, другая в Сербии. Одноимённые объекты легко различимы 
по номерам: \wdqName{Obnitsa}{16583338} и \wdqName{Obnitsa}{959190}.}
%
\begin{lstlisting}[ language=Python,
                    caption={Получение содержимого страницы Викиданных о реке Обнице в Польше},
                    label=lst:page-get
                  ]
import pywikibot
site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q16583338")     # river in Poland
print(page.get())
\end{lstlisting}

Сохраняем файл и выполняем его, набрав следующую инструкцию: ``py pwb.py test.py''.

Если все работает корректно, мы увидим в нашей консоли весь текст, написанный в статье о реке Обница в Викиданных (элемент Q16583338). В первой строке кода мы импортировали Pywikibot. Затем мы указали название проекта, над которым хотим работать, как мы могли бы сделать это на любом языке Википедии или Commons. Затем мы указываем конкретный элемент и, наконец, говорим ему, что хотим получить весь контент.

«Page»(страница)~--- это модуль, включающий множество полезных методов. Чтобы узнать больше об этом, мы можем перейти к официальной документации. В дополнение к методу «get» в нашем распоряжении есть возможность узнать заголовок элемента с помощью метода «title»~(листинг~\ref{lst:page-title}):
\marginnote[0.0cm]{См. дополнительную информацию о модуле ''Page'' \url{https://doc.wikimedia.org/pywikibot/master/_modules/pywikibot/page.html}}

\begin{lstlisting}[ language=Python,
                    caption={Получение заголовка элемента с номером Q16583338},
                    label=lst:page-title
                  ]
import pywikibot
site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q16583338")
print(page.title())
\end{lstlisting}

Мы также можем узнать, является ли этот элемент страницей перенаправления, с помощью метода isRedirectPage. Для этого изменим предыдущий элемент и укажем другой, который является страницей перенаправления (Q16583333)~(листинг~\ref{lst:is-redirected}).

\begin{lstlisting}[ language=Python,
                    caption={Получение ответа на вопрос, является ли элемент страницей перенаправления (истина или ложь)},
                    label=lst:is-redirected
                  ]
import pywikibot
site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u" Q16583333")
print(page.title())
print(page.isRedirectPage())
\end{lstlisting}

Обратите внимание, что до сих пор упражнения были очень простыми, но по мере усложнения мы должны быть осторожны с отступами, которые позволяют указать в языке Python, какая информация входит в структуры управления.

Предыдущее упражнение возвращает только истину или ложь, но обычно такой запрос нужен, чтобы узнать, является ли заданная страница перенаправлением или нет, и действовать соответствующим образом, предупреждая пользователя, что этот элемент является страницей перенаправления, как в следующем примере~(листинг~\ref{lst:attention}).

\begin{lstlisting}[ language=Python,
                    caption={Предупреждение пользователя о том, что элемент является страницей перенаправления},
                    label=lst:attention
                  ]
import pywikibot
site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u" Q16583333")
if (page.isRedirectPage()):
  print("Обратите внимание, это перенаправление, а не элемент")
\end{lstlisting}

Но что произойдет, если мы проанализируем несколько элементов и встретим тот, которого не существует? Возможно, наша программа вернёт несколько ошибок, потому что не сможет проанализировать содержимое элемента. Для этого мы можем отловить ошибки в Python, но мы также можем проверить, существует ли элемент~(листинг~\ref{lst:page-exists}).

\begin{lstlisting}[ language=Python,
                    caption={Проверка существования элемента},
                    label=lst:page-exists
                  ]
import pywikibot
site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u" Q107043778")
if not page.exists():
  print("Простите, но этот элемента не существует!")
\end{lstlisting}

Упражнение: узнайте, как мы можем фиксировать ошибки в Python и усовершенствуйте предыдущую программу, чтобы мы могли фиксировать возможные ошибки, возвращаемые программой.

Далее проанализируем элемент более основательно, чтобы узнать какие свойства он содержит. Для этого мы можем вызвать метод «properties», таким образом~(листинг~\ref{lst:page-properties}).

\begin{lstlisting}[ language=Python,
                    caption={Получение списка свойств элементов},
                    label=lst:page-properties
                  ]
import pywikibot
site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q16583338")
print(page.properties())
\end{lstlisting}

При выполнении этого скрипта мы видим, что этот метод возвращает словарь Python, и это потому, что метод «свойства» возвращает словарь со свойствами, содержащимися в этом элементе. Например, мы видим, что в свойстве page\_image\_free мы получаем изображение, которое появляется в элементе, что wb\_claims содержит количество свойств, содержащихся в элементе, или что wb\_sitelinks сообщает нам количество ссылок, связывающих этот элемент с проектами Викимедиа.

Метод \textit{contributors()} также возвращает словарь, содержащий пользователей, редактировавших этот элемент. Он покажет нам имена (ники) этих редакторов, а также число правок каждого из них. Ещё один метод ''revision\_count'' возвращает общее количество правок в элементе. Оба этих метода задействованы в~(листинге~\ref{lst:contributors-revision}).

\begin{lstlisting}[ language=Python,
                    caption={Перечисление редакторов элемента и числа правок},
                    label=lst:contributors-revision
                  ]
import pywikibot
site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q16583338")
print(page.contributors())
print(page.revision_count())
\end{lstlisting}

Существуют и другие методы, которые возвращают более сложную информацию, чем словарь данных, например, мы получим объект при обращении к методу ''connectedPages'' (связанные страница). Если мы обратимся к этому методу как в листинге 17.7 и выведем на печать с помощью функции \textit{print()}, то получим строчку: 

<pywikibot.data.api.PageGenerator object at 0x000002C6C7DB2FD0>.
Эта строка сообщает, что получен объект типа ''PageGenerator''. Прочитать содержимое объекта мы можем с помощью цикла for~(листинг~\ref{lst:for-loop}):

\begin{lstlisting}[ language=Python,
                    caption={Чтение объекта типа ''PageGenerator''},
                    label=lst:for-loop
                  ]
import pywikibot
site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q16583338")
for linked in page.linkedPages():
  print(linked)
\end{lstlisting}

Итак, с помощью метода ''page.linkedPages()'' мы получаем список тех ссылок, которые перечислены на исследуемой странице page. Сначала будут показаны элементы, а затем свойства (включая информацию, содержащуюся в ссылках). Очевидно, что если выбранный элемент не очень большой, количество ссылок также будет не очень большим, но если мы попробуем этот пример с очень большим элементом, количество ссылок будет значительным.

Чтобы узнать количество элементов, ссылающихся на заданный элемент, есть метод, называемый ''backlinks()'' который возвращает объект и который мы должны обойти, как мы делали в предыдущем упражнении~(листинг~\ref{lst:for-loop}). В зависимости от элемента мы можем получить пустой список, поэтому мы выберем элемент, связанный с другими элементами~(листинг~\ref{lst:back-links}.

\begin{lstlisting}[ language=Python,
                    caption={Использование метода ''backlinks()'' для получения элементов, ссылающихся на конкретный элемент},
                    label=lst:back-links
                  ]
import pywikibot
site=pywikibot.Site('wikidata', "wikidata")
page=pywikibot.Page(site, u"Q6980876")
for links in page.backlinks():
  print(links)
\end{lstlisting}

В этом случае мы выбрали другую реку, которая связана дважды: другой рекой и страницей перенаправления. Таким образом, мы можем узнать, сколько раз был связан определенный элемент.

Упражнение: примените на практике все, что увидели до этого момента, но используя элемент с низким номером, который, вероятно, содержит гораздо больше информации, чем примеры, которые мы использовали до сих пор.

В дополнение к модулю «Страница» Pywikibot предоставляет нам множество других возможностей. Например, введение одного элемента не имеет особого смысла, обычно мы хотим работать с несколькими элементами, чтобы проанализировать их и, при необходимости, изменить их. Для этого мы можем использовать запросы, которые мы выполняли на протяжении всего курса.

\section{Выполняемые запросы}
\label{sec:running queries}

Сначала перейдем в службу запросов Викиданных, чтобы создать наш запрос. Мы ищем возможные ошибки во введенных данных, например людей, у которых определенная страна указана в собственности P17. Это распространенная ошибка, поскольку многие пользователи вводят P17 вместо страны гражданства (P27).

Этот запрос может выглядеть так~(листинг~\ref{lst:page-get}):

\begin{lstlisting}[ language=SPARQL,
                    caption={Создание запроса на поиск ошибок},
                    label=lst:page-get
                  ]
SELECT ?item ?itemLabel WHERE {
  SERVICE wikibase:label { bd:serviceParam wikibase:language 
  "[AUTO_LANGUAGE],en". }
  ?item wdt:P31 wd:Q5;
    wdt:P17 wd:Q36.
}
\end{lstlisting}       

Мы должны проверить, возвращает ли запрос какое-либо значение, поскольку может оказаться, что ошибок нет. В этом случае мы можем изменить страну, поскольку наверняка будут другие страны с такой же ошибкой.

Когда мы получаем запрос, который возвращает любого человека, мы можем добавить запрос в нашу программу, например~(листинг~\ref{lst:page-get}):

\begin{lstlisting}[ language=SPARQL,
                    caption={Добавление запроса в программу, результат которой - отображение всех людей, для которых страной указана Польша},
                    label=lst:page-get
                  ]
import pywikibot
from pywikibot import pagegenerators
site=pywikibot.Site('wikidata', "wikidata")
query = """
  SELECT DISTINCT ?item WHERE {
    SERVICE wikibase:label { bd:serviceParam wikibase:language 
    "[AUTO_LANGUAGE],en". }
    ?item wdt:P31 wd:Q5.
    ?item wdt:P17 wd:Q36.
  } """

pages = pagegenerators.WikidataSPARQLPageGenerator(query, site=site)
for item in pages:
  print(item.title())
\end{lstlisting}    

Относительно предыдущих упражнений, мы импортировали только <<генераторы страниц>>, модуль, который позволяет нам генерировать список элементов из определенных фильтров в виде запроса SPARQL, как указано выше. Мы сохранили запрос в переменной под названием ''query'', а затем передали его в метод генераторов страниц под названием ''WikidataSPARQLPageGenerator''. Данные, возвращаемые этим методом, были обработаны с помощью цикла for, и мы отобразили заголовок элемента.

Вкратце, эта программа показывает нам всех людей, для которых Польша указана страной.

Мы уже можем получить несколько элементов одновременно. Теперь пора углубиться в их содержание. Вместо того, чтобы отображать заголовок статьи, мы будем отображать некоторые части ее содержания. Например, дополнительные ссылки, псевдонимы, ярлыки или утверждения~(листинг~\ref{lst:page-get}).

\begin{lstlisting}[ language=SPARQL,
                    caption={},
                    label=lst:page-get
                  ]
import pywikibot
from pywikibot import pagegenerators
site=pywikibot.Site('wikidata', "wikidata")
query = """

  SELECT DISTINCT ?item WHERE {
    SERVICE wikibase:label { bd:serviceParam wikibase:language 
    "[AUTO_LANGUAGE],en". }
    ?item wdt:P31 wd:Q5.
    ?item wdt:P17 wd:Q36.
  } """

pages = pagegenerators.WikidataSPARQLPageGenerator(query, site=site)
for item in pages:
  item.get()
  print(item.sitelinks)
  print(item.aliases)
  print(item.labels)
  print(item.claims)
\end{lstlisting} 

Упражнение: протестируйте запросы, которые вы выполнили ранее в курсе, и отобразите результаты в консоли с сообщениями, которые помогут вам узнать, что выполняется.

Мы показали информацию в элементах Викиданных, но теперь давайте посмотрим, как мы можем их изменить.

\section{Изменение значений, введенных в Викиданные}
\label{sec:modifying the values entered in Wikidata}

Поиск повторяющихся с течением времени ошибок - одна из задач бота-программиста, потому что в зависимости от задачи, выполняемой ботом, ее придется выполнять регулярно, и со временем улучшать поиск ошибок. Например, следующий запрос возвращает все профессии, отсортированные по количеству их использования в Викиданных~(листинг~\ref{lst:page-get}):

\begin{lstlisting}[ language=SPARQL,
                    caption={Отображение профессий, отсортированных по количеству их использование в Викиданных},
                    label=lst:page-get
                  ]
SELECT ?instanceLabel ?value WHERE {
  {
    SELECT ?instance (COUNT(DISTINCT ?item) AS ?value) WHERE { ?item
wdt:P106 ?instance. }
    GROUP BY ?instance
    ORDER BY DESC (?value)
  }
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
ORDER BY DESC (?value)
\end{lstlisting} 

Этот запрос можно использовать для проверки того, какие профессии используются неправильно или были введены вандалами. Просматривая список, мы видим, что есть некоторые профессии, которые неверны и содержат бессмысленную информацию, например, «Q7404672», «Q7319129», «Q7249866», «Q7244433» и «Q7208069». Мы можем составить список ошибок и показать биографии, в которых указаны эти профессии~(листинг~\ref{lst:page-get}).

\begin{lstlisting}[ language=SPARQL,
                    caption={Составление списка ошибок и отображение биографий},
                    label=lst:page-get
                  ]
import pywikibot
from pywikibot import pagegenerators
site=pywikibot.Site('wikidata', "wikidata")
delete_occupation={"Q7404672", "Q7319129", "Q7249866", "Q7244433", 
"Q7208069"}
for occupation in delete_occupation:
  query = """
    SELECT DISTINCT ?item WHERE {
      SERVICE wikibase:label { bd:serviceParam wikibase:
language "[AUTO_LANGUAGE],en". }
      ?item wdt:P31 wd:Q5.
      ?item wdt:P106 wd:""" + occupation + """.
    } """

  pages=pagegenerators.WikidataSPARQLPageGenerator(query, site=site)
  for item in pages:
    print("These are the people who have {occupation} as their 
occupation: {title}" . format(occupation=occupation, 
title=item.title()))
\end{lstlisting} 

Список создан в переменной ''delete\_occupation''. Мы проходим его с помощью цикла for, чтобы вызвать запрос для каждой из добавляемых нами профессий. На этот раз запрос отличается от предыдущего, в нем есть переменная, которая изменяется в зависимости от значения ''delete\_occupation''. Запрос будет запрашивать людей, чья профессия соответствует значению ''delete\_occupation'', и покажет это на экране.

Внимание: до сих пор мы использовали <<печать>> для отображения информации, содержащейся в переменных, но в предыдущем упражнении мы использовали <<формат>>, так как это рекомендуется для ясности строк.

Теперь, если мы уверены, что эта информация неверна, и мы хотим ее удалить, мы должны указать конкретное свойство, которое мы хотим удалить. Проблема в том, что в биографии может быть три профессии, и только одну из них мы хотим удалить. Мы не можем удалить все значения свойства, мы должны знать конкретные данные, которые нужно удалить.

Далее мы увидим, как это можно сделать~(листинг~\ref{lst:page-get}):

\begin{lstlisting}[ language=SPARQL,
                    caption={Корректное удаление},
                    label=lst:page-get
                  ]
import pywikibot
from pywikibot import pagegenerators
site=pywikibot.Site('wikidata', "wikidata")
delete_occupation={"Q7404672", "Q7319129", "Q7249866", "Q7244433", 
"Q7208069"}
for occupation in delete_occupation:
  query = """
    SELECT DISTINCT ?item WHERE {
      SERVICE wikibase:label { bd:serviceParam wikibase:language 
"[AUTO_LANGUAGE],en". }
      ?item wdt:P31 wd:Q5.
      ?item wdt:P106 wd:""" + occupation + """.
    } """

  pages = pagegenerators.WikidataSPARQLPageGenerator(query, 
  site=site)
  for item in pages:
    print("These are the people who have {occupation} as their 
occupation: {title}" . format(occupation=occupation, 
title=item.title()))
    item.get()

    for valor in item.claims['P106']:
      if (str(valor.getTarget())=='[[wikidata:' + occupation + 
']]'):
        print("<<<<< Deleting {occupation} of {title} >>>>>" . 
format(occupation=occupation, title=item.title()))
        item.removeClaims(valor, summary=u'Deleting erroneous 
values in P106')
\end{lstlisting} 

В предыдущем коде мы сохранили прежний код, но добавили последние строки, в которых мы просматриваем значения, содержащиеся в свойстве ''P106'', с помощью метода <<приложения>>. Если это совпадает с искомой профессией, мы удаляем его методом removeClaims. Этому методу требуется значение, которое мы хотим удалить, и сводка редактирования, чтобы показать остальным пользователям, что делается.

Упражнение: добавьте больше неправильных профессий в переменную ''delete\_occupation'' и запустите бота для удаления этих свойств.

Внимание: такие изменения могут вызвать множество проблем с Викиданными, и администраторы могут заблокировать вашу учетную запись. Внесите несколько изменений вначале и всегда проверяйте историю изменений, чтобы узнать, какая информация была изменена.
